# page

文章

* [ ] 待初稿
* [ ] [待完善](#page)
* [x] [已完成](#page) 

> 注：每一篇文章都应尽可能细致和完整。

## Java

[⇧ 返回顶部](#page)

* [x] [使用 DecimalFormat 格式化数字字符串](./src/201812/012025/)
* [x] [理解 Java 中的内部类](./src/201812/012215/)
* [ ] [Java 注解的基本原理和运用](./src/201812/020743)

[]()

* [x] [Java 设计模式：简介](./src/201904/012249/)
* [x] [Java 设计模式：策略模式](./src/201904/022004/)
* [x] [Java 设计模式：观察者模式](./src/201903/312355/)
* [x] [Java 设计模式：工厂模式和抽象工厂模式](./src/201904/022233/)
* [x] [Java 设计模式：单例模式](./src/201904/041927/)
* [x] [Java 设计模式：命令模式](./src/201904/050835/)
* [x] [Java 设计模式：适配器模式](./src/201904/052253/)
* [x] [Java 设计模式：外观模式](./src/201904/061257/)
* [x] [Java 设计模式：模板方法模式](./src/201904/062351/)
* [x] [Java 设计模式：组合模式](./src/201904/070746/)
* [x] [Java 设计模式：状态模式](./src/201904/070956/)
* [x] [Java 设计模式：代理模式](./src/201904/071120/)
* [x] [Java 设计模式：桥接模式](./src/201904/071450/)
* [x] [Java 设计模式：建造者模式](./src/201904/071659/)
* [x] [Java 设计模式：责任链模式](./src/201904/072101/)


## Kotlin

[⇧ 返回顶部](#page)

* [x] [关于学习 Kotlin 的资源汇总](./src/201812/021029/)

[]()

* [x] [Kotlin Examples - Hello World](./src/201811/292101/)
* [x] [Kotlin Examples - Variables](./src/201811/292103/)
* [x] [Kotlin Examples - Functions](./src/201811/292102/)
* [x] [Kotlin Examples - Classes](./src/201811/292105/)
* [x] [Kotlin Examples - Generics](./src/201811/292106/)
* [x] [Kotlin Examples - When, Loops, Ranges, Conditional Expression](./src/201811/292108/)
* [x] [Kotlin Examples - Object keyword](./src/201811/292116/)
* [x] [Kotlin Examples - Extension Functions and Properties](./src/201811/292119/)
* [x] [Kotlin Examples - let, with, run, also, apply](./src/201811/292120/)
* [x] [Kotlin Examples - Collections](./src/201811/292122/)
* [ ] [Kotlin Examples - Delegate](./src/201811/292140/)
* [ ] [Kotlin Examples - Else](./src/201811/292142/)

[]()

* [ ] [一篇文章了解 Kotlin 在 Android 中的基本使用](./src/201902/010848/)


## JS - ES - TS

[⇧ 返回顶部](#page)

* [x] [JavaScript 基础](./src/201812/022245/)
* [ ] [进一步了解 JavaScript 中的 Number、Array、Date 和 Boolean](./src/201812/041948/)

[]() 

* [ ] [ES6 对 ES5 原有对象的一些扩展](./src/201812/042153/)
* [ ] [通过 Promise 解决回调地狱问题](./src/201812/042217/)
* [ ] [通过 JSDoc 提高开发效率](./src/201812/042226/)

[]()

* [ ] TypeScript 基础


## Android

[⇧ 返回顶部](#page)

* [ ] [AppLinks 使用总结](./src/201812/042238/)
* [ ] [DeepLinks 使用总结](./src/201812/042239/)
* [ ] [Spannable 相关技术总结](./src/201812/042240/)
* [ ] [你真的知道 Toast 怎么用了吗](./src/201812/042241/)
* [ ] [全面了解 Android 中的广播机制（一）：基础知识](./src/201812/042242/)
* [ ] [全面了解 Android 中的广播机制（二）：实践与封装](./src/201812/042243/)
* [ ] [Android 中的 Service（一）: 是什么](./src/201812/042244/)
* [ ] [Android 中的 Service（二）: 怎么用](./src/201812/042245/)
* [ ] [Android 中的 Service（三）: 范例解析](./src/201812/042246/)
* [ ] [Androud 中的运行时权限：概述](./src/201812/042247/)
* [ ] [关于 Activity 的几个最佳实践](./src/201812/042248/)
* [ ] [如何对 App 的前后台切换进行监听](./src/201812/042249/)
* [ ] [Android 中的进程与线程](./src/201812/042250/)
* [x] [深入理解 Handler](./src/201904/210834/)
* [ ] [深入理解 AsyncTask](./src/201812/042251/)
* [ ] [深入理解 View](./src/201812/042309/)
* [ ] [通过注解改进代码检查](./src/201812/042311/)
* [ ] [Android Studio 中的调试技巧](./src/201812/042310/)
* [ ] [Toolbar 使用总结](./src/201812/042313/)
* [ ] [TabLayout 基本使用与源码分析](./src/201812/042312/)

[]()

* [ ] Android 源码设计模式：单例
* [ ] Android 源码设计模式：Builder 
* [ ] Android 源码设计模式：原型
* [ ] Android 源码设计模式：工厂方法
* [ ] Android 源码设计模式：抽象工厂方法
* [ ] Android 源码设计模式：策略
* [ ] Android 源码设计模式：状态
* [ ] Android 源码设计模式：责任链
* [ ] Android 源码设计模式：解释器
* [ ] Android 源码设计模式：命令
* [ ] Android 源码设计模式：观察者
* [ ] Android 源码设计模式：备忘录
* [ ] Android 源码设计模式：迭代器
* [ ] Android 源码设计模式：模板
* [ ] Android 源码设计模式：访问者
* [ ] Android 源码设计模式：中介者
* [ ] Android 源码设计模式：代理
* [ ] Android 源码设计模式：组合
* [ ] Android 源码设计模式：适配器
* [ ] Android 源码设计模式：装饰
* [ ] Android 源码设计模式：享元
* [ ] Android 源码设计模式：外观
* [ ] Android 源码设计模式：桥接

[]()

* [ ] [Logger 解析（一）：基础用法](./src/201812/042252/)
* [ ] [Logger 解析（二）：相关源码探讨 - LogCat](./src/201812/042253/)
* [ ] Logger 解析（三）：相关源码探讨 - Disk
* [ ] [Logger 解析（四）：封装自己的日志库](./src/201812/042254/)

[]()

* [ ] [Volley 指导：开始](./src/201812/042255/)
* [ ] [Volley 指导：发起一个简单请求](./src/201812/042256/)
* [ ] [Volley 指导：发起一个标准请求](./src/201812/042257/)
* [ ] [Volley 指导：自定义请求](./src/201812/042258/)
* [ ] [Volley 指导：设置请求队列](./src/201812/042259/)
* [ ] [Volley 源码分析：执行流程](./src/201812/042301/)

[]()

* [ ] Picasso 框架 基本使用 API
* [ ] Picasso 源码 with 方法：内存缓存 Lrucache 和线程池的调度
* [ ] Picasso 源码 with：dispatcher 如何完成线程切换
* [ ] Picasso 源码 with：NetworkRequestHandler 处理图片请求和回调
* [ ] Picasso 源码 load 方法
* [ ] Picasso 源码 into 方法：Action & BitmapHunter
* [ ] Picasso 源码 into 方法：线程池 & PicassoFutureTask
* [ ] Picasso 源码 into：线程开启如何执行图片加载请求？
* [ ] Picasso 源码 into：OkHttp 和 UrlConnectionDownloader 下载图片
* [ ] Picasso 源码 into 方法：完成加载

[]()

* [ ] [OkHttp 基础：快速开始](./src/201812/042302/)
* [ ] [OkHttp 基础：Calls](./src/201812/042303/)
* [ ] [OkHttp 基础：Connections](./src/201812/042304/)
* [ ] [OkHttp 基础：Recipes](./src/201812/042305/)
* [ ] [OkHttp 基础：Interceptors](./src/201812/042306/)
* [ ] [OkHttp 基础：HTTPS](./src/201812/042307/)
* [ ] [OkHttp 基础：Events](./src/201812/042308/)
* [ ] OkHttp 框架流程分析
* [ ] OkHttp 同步请求方法
* [ ] OkHttp 异步请求方法
* [ ] OkHttp 同步请求流程和源码分析
* [ ] OkHttp 异步请求流程和源码分析 - 1
* [ ] OkHttp 异步请求流程和源码分析 - 2
* [ ] OkHttp 任务调度核心类 dispatcher 解析 - 1
* [ ] OkHttp 任务调度核心类 dispatcher 解析 - 2
* [ ] OkHttp 拦截器流程
* [ ] OkHttp 拦截器链介绍
* [ ] OkHttp 之 RetryAndFollowUpInterceptor 解析
* [ ] OkHttp 之 BridgeInterceptor 解析
* [ ] OkHttp 缓存策略源码分析：put 方法
* [ ] OkHttp 缓存策略源码分析：get 方法
* [ ] OkHttp 拦截器之 CacheInterceptor 解析
* [ ] OkHttp 拦截器之 ConnectInterceptor 解析-1
* [ ] OkHttp 拦截器之 ConnectInterceptor 解析-2
* [ ] OkHttp 连接池：put, get 方法
* [ ] OkHttp 连接池：connection 回收
* [ ] OkHttp 拦截器之 CallServerInterceptor 解析
* [ ] OkHttp 面试: Socket - 1
* [ ] OkHttp 面试: Socket - 2
* [ ] OkHttp 面试: HttpClient & HttpUrlConnection
* [ ] OkHttp 面试: OkHttp来实现WebSocket连接
* [ ] OkHttp 面试: WebSocket & 轮询相关
* [ ] OkHttp 面试: Http 缓存、Etag 等标示作用
* [ ] OkHttp 面试: 断点续传原理 & OkHttp 如何实现
* [ ] OkHttp 面试：多线程下载
* [ ] OkHttp 面试：文件上传 & OkHttp 如何处理文件上传
* [ ] OkHttp 面试：如何解析Json类型数据
* [ ] OkHttp 面试：Https／对称加密 & 不对称加密

[]()

* [ ] Retrofit 流程分析
* [ ] Retrofit 概述
* [ ] Retrofit 官网例子解析
* [ ] Retrofit 请求过程 7 步骤详解
* [ ] Retrofit 静态代理模式讲解
* [ ] Retrofit 动态代理模式讲解
* [ ] Retrofit 网络通信流程 8 步骤 & 7 个关键成员变量解析
* [ ] Retrofit 中 builder 构建者模式 & builder 内部类解析
* [ ] Retrofit 中 baseurl／converter／calladapter 解析
* [ ] Retrofit 中 build 方法完成 Retrofit 对象创建流程解析
* [ ] Retrofit 中 RxjavaCallAdapterFactory 内部构造与工作原理解析
* [ ] Retrofit 中网络请求接口实例解析
* [ ] Retrofit 中 serviceMethod 对象解析
* [ ] Retrofit 中 okHttpCall 对象和 adapt 返回对象解析
* [ ] Retrofit 中同步请求 & 重要参数解析
* [ ] Retrofit 中异步请求解析
* [ ] Retrofit 设计模式解析 - 1：构建者模式
* [ ] Retrofit 设计模式解析 - 2：工厂模式
* [ ] Retrofit 设计模式解析 - 3：外观模式
* [ ] Retrofit 设计模式解析 - 4：策略模式
* [ ] Retrofit 设计模式解析 - 5：适配器模式
* [ ] Retrofit 设计模式解析 - 6：动态代理模式／观察者
* [ ] Retrofit 面试题：retfrofit 线程切换（异步机制 Looper)
* [ ] Retrofit 面试题：rxjava 和 Retrofit 如何结合进行网络请求
* [ ] Retrofit 面试题：Hook 与动态代理
* [ ] Retrofit 面试题：Android MVC 架构优势和缺点
* [ ] Retrofit 面试题：MVP 优点和缺点
* [ ] Retrofit 面试题：sp 跨进程 & apply 和 commit 方法

[]()

* [ ] Glide 框架流程分析
* [ ] Glide 框架介绍 - 1
* [ ] Glide 框架介绍 - 2
* [ ] Glide 图片加载流程和源码分析 - 1：with 方法（requestManager 获取)
* [ ] Glide 图片加载流程和源码分析 - 2：with 方法（requestManagerRetriever 的 get 方法)
* [ ] Glide 图片加载流程和源码分析 - 3：load 方法
* [ ] Glide 图片加载流程和源码分析 - 4：into 方法（buildTarget）
* [ ] Glide 图片加载流程和源码分析 - 5：into 方法（request 建立和 begin 方法）
* [ ] Glide 图片加载流程和源码分析 - 6：into 方法（Loadprovider）
* [ ] Glide 图片加载流程和源码分析 - 7：into 方法（硬盘缓存／内存缓存)
* [ ] Glide 图片加载流程和源码分析 - 8：into 方法（内存缓存的读取）
* [ ] Glide 图片加载流程和源码分析 - 9：into 方法（内存缓存的写入）
* [ ] Glide 面试一：bitmap & oom & 优化 bitmap
* [ ] Glide 面试二：三级缓存 * [ ] lrucache

[]()

* [ ] EventBus 框架核心概念：事件传递／EventBus 的优点／传统 handler 通信的两种方式
* [ ] EventBus 框架基本用法
* [ ] EventBus 框架源码解析 - 1：EventBus 对象构建／如何进行线程调度
* [ ] EventBus 框架源码解析 - 2：subscribe 注解／threadMode
* [ ] EventBus 框架源码解析 - 3：register 订阅（上）
* [ ] EventBus 框架源码解析 - 4：register 订阅（中）
* [ ] EventBus 框架源码解析 - 5：register 订阅（下）
* [ ] EventBus 框架源码解析 - 6：subscribe 方法完成订阅（上）
* [ ] EventBus 框架源码解析 - 7：subscribe 方法完成订阅（下）
* [ ] EventBus 框架源码解析 - 8：发送事件 post

[]()

* [ ] ButterKnife 的引言和基本使用
* [ ] ButterKnife 原理必备知识点 1：注解
* [ ] ButterKnife 原理必备知识点 2：APT 工作原理
* [ ] ButterKnife 原理必备知识点 3：反射 + 运行时注解举例
* [ ] ButterKnife 原理分析 - 1：注解处理器如何处理注解和保存注解
* [ ] ButterKnife 原理分析 - 2：如何生成 findviewById 代码

[]()

* [ ] Android 常见内存泄漏分析 - 1：单例 VS 非静态内部类
* [ ] Android 常见内存泄漏分析 - 2：handler & 解决办法
* [ ] Android 常见内存泄漏分析 - 3：线程 & WebView

[]()

* [ ] LeakCanary 预备知识：Android 性能优化 & Gcroots
* [ ] LeakCanary 内存框架：内存泄漏基础 & 为什么需要
* [ ] LeakCanary 原理分析 - 1：Leakcanary 原理概述和弱引用／引用队列
* [ ] LeakCanary 原理分析 - 2：ActivityRefWatcher 如何监视 Activity
* [ ] LeakCanary 原理分析 - 3：.hprof 转换 snapshot
* [ ] LeakCanary 原理分析 - 4：查找内存泄漏引用和最短泄漏路径
* [ ] LeakCanary 面试题：Application & 内存
* [ ] LeakCanary 面试题：性能数据上报：网络流量和冷启动
* [ ] LeakCanary 面试题：性能数据上报：UI 卡顿和内存占用

[]()

* [ ] BlockCanary 背景／UI 卡顿原理／UI 卡顿常见原因
* [ ] BlockCanary 使用／阀值参数
* [ ] BlockCanary 核心原理实现和流程图简述
* [ ] BlockCanary 源码解析 - 1：框架初始化
* [ ] BlockCanary 源码解析 - 2：stacksampler／cpusampler／start 方法
* [ ] BlockCanary 面试一：anr场景／原因／解决
* [ ] BlockCanary 面试二：watchdog-anr 如何检测 anr
* [ ] BlockCanary 面试三：new Thread 开启线程的 4 点弊端
* [ ] BlockCanary 面试四：线程间通信：子线程 -- UI 线程
* [ ] BlockCanary 面试五：主线程 -- 子线程 (handlerThread-IntentService)
* [ ] BlockCanary 面试六：多进程的 4 点好处与问题／voliate 关键字
* [ ] BlockCanary 面试七：voliate 关键字和单例的写法

[]()

* [ ] Dagger2 引言：依赖注入和使用场景
* [ ] Dagger2 四种注入方式和依赖注入总结
* [ ] Dagger2 的四种基本注解：`@inject` 注解
* [ ] Dagger2 的四种基本注解：`@component` 注解
* [ ] Dagger2 的 inject 和 component 注解实例和源码分析
* [ ] Dagger2 的 `@Module` 和 `@Provides` 注解
* [ ] Dagger2 的 `@Module` 和 `@Provides` 注解实例和代码分析

[]()

* [ ] [MPAndroidChart 笔记：概述](./src/201904/082240/)
* [ ] [MPAndroidChart 笔记：开始](./src/201904/082241/)
* [ ] [MPAndroidChart 笔记：与图表进行手势交互](./src/201904/082242/)
* [ ] [MPAndroidChart 笔记：坐标轴，X轴，Y轴，Labels](./src/201904/082243/)
* [ ] [MPAndroidChart 笔记：设置数据，设置颜色](./src/201904/082244/)
* [ ] [MPAndroidChart 笔记：数据格式器](./src/201904/082245/)
* [ ] [MPAndroidChart 笔记：图表的具体设置](./src/201904/082246/)
* [ ] [MPAndroidChart 笔记：图例](./src/201904/082247/)
* [ ] [MPAndroidChart 笔记：动态和实时数据](./src/201904/082248/)
* [ ] [MPAndroidChart 笔记：修改视窗](./src/201904/082249/)
* [ ] [MPAndroidChart 笔记：动画](./src/201904/082250/)
* [ ] [MPAndroidChart 笔记：MarkerView](./src/201904/082251/)
* [ ] [MPAndroidChart 笔记：ChartData & DataSet](./src/201904/082252/)

[]()

* [ ] [HenCoder 笔记 - 自定义 View：绘制基础](./src/201812/310950/)
* [ ] [HenCoder 笔记 - 自定义 View：Paint 详解](./src/201812/310951/)


## iOS

[⇧ 返回顶部](#page)

* [ ] [OC 基础和语法介绍](./src/201812/021039/)
* [ ] [iOS 中的视图和控件 (Views and Controls)](./src/201811/301958/)

[]()

* [x] [Swift 编码之旅](./src/201812/021352/)

[]()

* [ ] [使用 Swift 开发 iOS 应用：序言](./src/201812/091240/)
* [x] [使用 Swift 开发 iOS 应用：构建基本 UI](./src/201812/091241/)
* [x] [使用 Swift 开发 iOS 应用：将 UI 连接到代码](./src/201812/091242/)
* [x] [使用 Swift 开发 iOS 应用：使用视图控制器](./src/201812/091243/)
* [x] [使用 Swift 开发 iOS 应用：实现自定义控件](./src/201812/091244/)
* [x] [使用 Swift 开发 iOS 应用：定义你的数据模型](./src/201812/091245/)
* [ ] [使用 Swift 开发 iOS 应用：创建表视图](./src/201812/091246/)
* [ ] [使用 Swift 开发 iOS 应用：实现导航](./src/201812/091247/)
* [ ] [使用 Swift 开发 iOS 应用：实现编辑和删除行为](./src/201812/091248/)
* [ ] [使用 Swift 开发 iOS 应用：持久化数据](./src/201812/091249/)

## React 

* [ ] [React 基础知识和使用方式](./src/201812/042314/)

[]()

* [ ] [React 实战进阶 - 开始](./src/201812/310952/)  
* [ ] [React 实战进阶 - React 出现的历史背景及特性介绍](./src/201812/310953/)
* [ ] [React 实战进阶 - 以组件方式考虑 UI 的构建](./src/201812/310954/)
* [ ] [React 实战进阶 - JSX 语法的本质不是模板引擎，只是一种语法糖](./src/201812/310955/)
* [ ] [React 实战进阶 - React 组件的生命周期及其使用场景](./src/201812/310956/)
* [ ] [React 实战进阶 - 理解 Virtual DOM 的工作原理，理解 key 属性的作用](./src/201812/310957/)
* [ ] [React 实战进阶 - 组件复用的其它形式：高阶组件和函数作为子组件](./src/201812/310958/)
* [ ] [React 实战进阶 - 理解新的 Context API 及其使用场景](./src/201812/310959/)
* [ ] [React 实战进阶 - 使用脚手架工具创建 React 项目：Create React App，Rekit，Codesandbox](./src/201812/311001/)
* [ ] [React 实战进阶 - 打包和部署：静态服务器，CDN 或 Github Pages](./src/201812/311002/)
* [ ] [React 实战进阶 - Redux(1) 前端为何需要状态管理库](./src/201812/311003/)
* [ ] [React 实战进阶 - Redux(2) 深入理解 Store，action，reducer](./src/201812/311004/)
* [ ] [React 实战进阶 - Redux(3) 在 React 中使用 Redux](./src/201812/311005/)
* [ ] [React 实战进阶 - Redux(4) 理解异步 action，Redux 中间件](./src/201812/311006/)
* [ ] [React 实战进阶 - Redux(5) 如何组织 action 和 reducer](./src/201812/311007/)
* [ ] [React 实战进阶 - Redux(6) 理解 Redux 运行的基础：不可变数据 (Immutability)](./src/201812/311008/)
* [ ] [React 实战进阶 - React Router(1) 路由不只是页面切换，更是代码组织方式](./src/201812/311009/)
* [ ] [React 实战进阶 - React Router(2) 参数定义，嵌套路由的使用场景](./src/201812/311010/)
* [ ] [React 实战进阶 - UI 组件库对比和介绍 Ant.Design，Material UI，Semantic UI](./src/201812/311011/)
* [ ] [React 实战进阶 - 使用 Next.js 创建服务器渲染的 React 应用](./src/201812/311012/)
* [ ] [React 实战进阶 - 使用 Jest，Enzyme 等工具进行单元测试](./src/201812/311013/)
* [ ] [React 实战进阶 - 常用开发调试工具：ESLint，Prettier，React DevTool，Redux DevTool](./src/201812/311014/)
* [ ] [React 实战进阶 -  前端项目的理想架构：可维护，可扩展，可测试，易开发，易构建](./src/201812/311015/)
* [ ] [React 实战进阶 - 拆分复杂度(1) 按领域模型 (feature) 组织代码，降低耦合度](./src/201812/311016/)
* [ ] [React 实战进阶 - 拆分复杂度(2) 如何组织 component，action 和 reducer](./src/201812/311017/)
* [ ] [React 实战进阶 - 拆分复杂度(3) 如何组织 React Router 的路由配置](./src/201812/311018/)
* [ ] [React 实战进阶 - 使用 Rekit 构建可扩展的 React 应用(1)：创建项目，代码生成和重构](./src/201812/311019/)
* [ ] [React 实战进阶 - 使用 Rekit 构建可扩展的 React 应用(2)：遵循最佳实践，保持代码一致性](./src/201812/311020/)
* [ ] [React 实战进阶 - 使用 React Router 管理登录和授权](./src/201812/311021/)
* [ ] [React 实战进阶 - 实现表单(1)：初始数据，提交和跳转](./src/201812/311022/)
* [ ] [React 实战进阶 - 实现表单(2)：错误处理，动态表单元素，内容动态加载](./src/201812/311023/)
* [ ] [React 实战进阶 - 列表页(1)：搜索，数据缓存和分页](./src/201812/311024/)
* [ ] [React 实战进阶 - 列表页(2)：加载状态，错误处理](./src/201812/311025/)
* [ ] [React 实战进阶 - 页面数据需要来源多个请求的处理](./src/201812/311026/)
* [ ] [React 实战进阶 - 内容页的加载和缓存](./src/201812/311027/)
* [ ] [React 实战进阶 - 基于 React Router 实现分布操作](./src/201812/311028/)
* [ ] [React 实战进阶 - 常见页面布局的实现](./src/201812/311029/)
* [ ] [React 实战进阶 - 使用 React Portals 实现对话框，使用 antd 对话框](./src/201812/311030/)
* [ ] [React 实战进阶 - 继承第三方 js 库：以 d3.js 为例](./src/201812/311031/)
* [ ] [React 实战进阶 - 基于路由实现菜单导航](./src/201812/311032/)
* [ ] [React 实战进阶 - React 中施放的实现](./src/201812/311033/)
* [ ] [React 实战进阶 - 性能永远是第一需求：时刻考虑性能问题](./src/201812/311034/)
* [ ] [React 实战进阶 - 网络性能优化：自动化按需加载](./src/201812/311035/)
* [ ] [React 实战进阶 - 使用 reselect 避免重复计算](./src/201812/311036/)
* [ ] [React 实战进阶 - 下一代 React：异步渲染](./src/201812/311037/)
* [ ] [React 实战进阶 - 使用 Chrome DevTool 进行性能调优](./src/201812/311038/)



## React Native

[⇧ 返回顶部](#page)

* [ ] [React Native 代码规范](./src/201812/301600/)
* [ ] [一个刚初始化好的 React Native 项目是怎样的](./src/201812/042346/)
* [ ] [如何引入第三方 React Native npm 包](./src/201812/042347/)
* [ ] [在 React Native 中如何组织项目和管理静态资源【译】](./src/201812/042348/)

[]()

* [x] [React Native - 属性和状态](./src/201811/292238/)
* [x] [React Native - 样式、高度和宽度](./src/201811/292255/)
* [x] [React Native - 详解 Flexbox 和 Layout Props](./src/201812/042349/)
* [x] [React Native - 通过 TextInput 处理文本输入](./src/201812/042350/)
* [x] [React Native - 完全理解事件处理](./src/201812/042351/)
* [ ] [React Native - 使用 ScrollView](./src/201812/042352/)
* [ ] [React Native - 特定于平台的代码](./src/201812/042353/)
* [ ] [React Native - 页面间的导航跳转](./src/201812/042354/)
* [ ] [React Native - 显示图片](./src/201812/042355/)
* [ ] [React Native - 动画](./src/201812/042356/)
* [ ] [React Native - 调试](./src/201812/042357/)
* [ ] [React Native - ActivityIndicator](./src/201812/042358/)
* [ ] [React Native - Button](./src/201812/042359/)
* [ ] [React Native - FlatList](./src/201812/050001/)
* [ ] [React Native - Image](./src/201812/050002/)
* [ ] [React Native - RefreshControl](./src/201812/050003/)
* [ ] [React Native - Slider](./src/201812/050004/)
* [ ] [React Native - Switch](./src/201812/050005/)
* [ ] [React Native - Text](./src/201812/050006/)
* [ ] [React Native - Alert](./src/201812/050007/)

[]()

* [ ] [React Navigation - 开始](./src/201812/301541/)
* [ ] [React Navigation - 在页面间跳转](./src/201812/301542/)
* [ ] [React Navigation - 通过路由传递参数](./src/201812/301543/)
* [ ] [React Navigation - 配置标题栏](./src/201812/301544/)
* [ ] [React Navigation - 标题栏按钮](./src/201812/301545/)
* [ ] [React Navigation - 打开一个全屏模态](./src/201812/301546/)
* [ ] [React Navigation - 标签导航](./src/201812/301547/)
* [ ] [React Navigation - 身份验证流](./src/201812/301548/)


## Flutter

* [ ] [Flutter 示例与解析](./src/201903/031218/)

[]() 

* [ ] Flutter 入门三部曲：学习 Dart 语法
* [ ] [Flutter 入门三部曲：看尽 Widget 繁华](./src/201903/251941/)
* [ ] Flutter 入门三部曲：站在大一点的视角来管理整个项目


## Spring Boot

* [ ] [Spring Boot 学习笔记：介绍](./src/201904/072312/)
* [ ] [Spring Boot 学习笔记：开发第一个应用程序](./src/201904/072313/)


## Git

* [ ] [谈谈软件配置管理](./src/201904/272100/)

[]()

* [ ] [Git 快速学习](./src/201904/280232/)
* [ ] [Git 工作流程](./src/201904/281314/)
* [ ] [Git 常用命令总结](./src/201904/271322/)


## ReactiveX

[⇧ 返回顶部](#page)

* [ ] [ReactiveX 概述](./src/201812/310930/)
 
[]()

* [ ] [RxJava 基础知识：开始](./src/201812/310931/)
* [ ] [RxJava 基础知识：Observable](./src/201812/310932/)
* [ ] [RxJava 基础知识：Flowable](./src/201812/310933/) 
* [ ] [RxJava 基础知识：创建操作符](./src/201812/310934/) 
* [ ] [RxJava 基础知识：转换操作符](./src/201812/310935/)
* [ ] [RxJava 基础知识：过滤操作符](./src/201812/310936/)
* [ ] [RxJava 基础知识：合并操作符](./src/201812/310937/)
* [ ] [RxJava 基础知识：错误处理操作符](./src/201812/310938/)
* [ ] [RxJava 基础知识：工具类操作符](./src/201812/310939/)
* [ ] [RxJava 基础知识：条件和布尔操作符](./src/201812/310940/)
* [ ] [RxJava 基础知识：数学和集合操作符](./src/201812/310941/)
* [ ] [RxJava 基础知识：背压操作符](./src/201812/310942/)
* [ ] [RxJava 基础知识：连接操作符](./src/201812/310943/)
* [ ] [RxJava 基础知识：操作符决策树](./src/201812/310944/)

[]()

* [ ] RxJava 源码解析：基本用法和观察者模式
* [ ] RxJava 源码解析：观察者模式和基本用法
* [ ] RxJava 源码解析：如何创建 Observable & observer／subscriber
* [ ] RxJava 源码解析：如何创建 subscriber 以及如何完成订阅
* [ ] RxJava 源码解析：操作符之 map 基本使用
* [ ] RxJava 源码解析：操作符之 map 源码探究：lift
* [ ] RxJava 源码解析：操作符之 flatmap
* [ ] RxJava 源码解析：线程控制 - 多线程编程准则 & RxJava 如何处理多线程 & Schedulers
* [ ] RxJava 源码解析：线程控制 - 两个小例子 & observeOn 和 SubscribeOn
* [ ] RxJava 源码解析：线程控制 - SubscribeOn 源码剖析
* [ ] RxJava 源码解析：线程控制 - ObserveOn 源码剖析 & subscribeOn 可以调用几次

[]()

* [ ] [RxJs 基础知识：开始](./src/201812/310945/) 
* [ ] [RxJs 基础知识：可观察者对象、观察者和订阅](./src/201812/310946/)
* [ ] [RxJs 基础知识：主体](./src/201812/310947/)
* [ ] [RxJs 基础知识：调度器](./src/201812/310949/)
* [ ] [RxJs 基础知识：操作符](./src/201812/310948/) 
* [ ] RxJs 基础知识：创建操作符
* [ ] RxJs 基础知识：转换操作符
* [ ] RxJs 基础知识：过滤操作符
* [ ] RxJs 基础知识：组合操作符
* [ ] RxJs 基础知识：多播操作符
* [ ] RxJs 基础知识：错误处理操作符
* [ ] RxJs 基础知识：工具操作符
* [ ] RxJs 基础知识：条件和布尔操作符
* [ ] RxJs 基础知识：数学和聚合操作符


## Epilog

* There is no any license of any article in this repo, you can copy or reship to anywhere as you want.
* If you find something wrong in the any article, it is awesome to submit an issue or pull a request to this repo.
* If this repo is helpful for you, give it a little star so i can konw thar.
* Anyway, thanks so much for your time.



