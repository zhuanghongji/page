# 统计一下这些年买的部分技术书籍及其主要章节

<br/>

**概述**

统计的目的是为了方便自己快速查找知识点，以形成更系统的学习体系。

<br/>
<br/>

**书籍列表**

* 数据结构与算法分析：Java 语言描述（第2版）
* Effective Java 中文版（原书第3版）
* Java 并发编程实战
* Kotlin 从零到精通 Android 开发
* Android 应用开发进阶
* RxJava 2.x 实战
* 音视频开发进阶指南：基于 Android 与 iOS 平台的实践
* 新时期的 Node.js 入门
* 深入浅出 Webpack
* App 后台开发运维和架构实践
* 深入理解 Android 自动化测试
* Kotlin 核心编程
* Java 并发编程的艺术
* 漫画算法：小灰的算法之旅
* FFmpeg 从入门到精通
* Android 全埋点解决方案
* Android 移动性能实战
* Android Gradle 权威指南
* JavaScript 忍者秘籍 第2版
* Git 高手之路
* Android 组件化架构
* React 进阶之路
* 深入探索 Android 热修复技术原理



**书籍目录**

数据结构与算法分析：Java 语言描述（第2版）
<table>
  <tr>
    <td>引论</td>
    <td>
      <ul>
        <li>数学知识复习</li>
        <li>递归简论</li>
        <li>实现泛型特性构件 pre-Java5</li>
        <li>利用 Java5 泛性实现泛型特性成分</li>
        <li>函数对象</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>算法分析</td>
    <td>
      <ul>
        <li>数学基础</li>
        <li>模型</li>
        <li>要分析的问题</li>
        <li>运行时间计算</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>表、栈和队列</td>
    <td>
      <ul>
        <li>抽象数据类型</li>
        <li>表 ADT</li>
        <li>JavaCollections API 中的表</li>
        <li>ArrayList 类的实现</li>
        <li>LinkedList 类的实现</li>
        <li>栈 ADT</li>
        <li>队列 ADT</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>树</td>
    <td>
      <ul>
        <li>预备知识</li>
        <li>二叉树</li>
        <li>查找树 ADT - 二叉查找树</li>
        <li>AVL 树</li>
        <li>伸展树</li>
        <li>树的遍历</li>
        <li>B 树</li>
        <li>标准库中的集合与映射</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>散列</td>
    <td>
      <ul>
        <li>一般想法</li>
        <li>散列函数</li>
        <li>分离链接法</li>
        <li>不用链表的散列表</li>
        <li>再散列</li>
        <li>标准库中的散列表</li>
        <li>可扩散列</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>优先队列（堆）</td>
    <td>
      <ul>
        <li>模型</li>
        <li>一些简单的实现</li>
        <li>二叉堆</li>
        <li>优先队列的应用</li>
        <li>d-堆</li>
        <li>左式堆</li>
        <li>斜堆</li>
        <li>二项队列</li>
        <li>标准库中的优先队列</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>排序</td>
    <td>
      <ul>
        <li>预备知识</li>
        <li>插入排序</li>
        <li>一些简单排序算法的下界</li>
        <li>希尔排序</li>
        <li>堆排序</li>
        <li>归并排序</li>
        <li>快速排序</li>
        <li>排序算法的一般下界</li>
        <li>桶式排序</li>
        <li>外部排序</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>不相交集类</td>
    <td>
      <ul>
        <li>等价关系</li>
        <li>动态等价性问题</li>
        <li>基本数据结构</li>
        <li>灵巧求并算法</li>
        <li>路径压缩</li>
        <li>路径压缩和按秩求并的最坏情形</li>
        <li>一个应用</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>图论算法</td>
    <td>
      <ul>
        <li>若干定义</li>
        <li>拓扑排序</li>
        <li>最短路径算法</li>
        <li>网络流问题</li>
        <li>最小生成树</li>
        <li>深度优先搜索的应用</li>
        <li>NP完全性介绍</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>算法设计技巧</td>
    <td>
      <ul>
        <li>贪婪算法</li>
        <li>分治算法</li>
        <li>动态规划</li>
        <li>随机化算法</li>
        <li>回溯算法</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>摊还分析</td>
    <td>
      <ul>
        <li>一个无关的智力问题</li>
        <li>二项队列</li>
        <li>斜堆</li>
        <li>斐波那契堆</li>
        <li>伸展树</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>高级数据结构及其实现</td>
    <td>
      <ul>
        <li>自顶向下伸展树</li>
        <li>红黑树</li>
        <li>确定性跳跃表</li>
        <li>AA 树</li>
        <li>treap 树</li>
        <li>kd 树</li>
        <li>配对堆</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

Effective Java 中文版（原书第3版）
<table>
  <tr>
    <td>引言</td>
    <td>
      <ul>
        <li>--</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>创建和销毁对象</td>
    <td>
      <ul>
        <li>用静态工厂方法代替构造器</li>
        <li>遇到多个构造器参数时要考虑使用构建器</li>
        <li>用私有构造器或者枚举类型强化 Singleton 属性</li>
        <li>通过私有构造器强化不可实例化的能力</li>
        <li>优先考虑依赖注入来引用资源</li>
        <li>避免创建不必要的对象</li>
        <li>消除过期的对象引用</li>
        <li>避免使用终结方法和清除方法</li>
        <li>try-with-resources 优先于 try-f?inally</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>对于所有对象都通用的方法</td>
    <td>
      <ul>
        <li>覆盖 equals 时请遵守通用约定</li>
        <li>覆盖 equals 时总要覆盖hashCode</li>
        <li>始终要覆盖 toString</li>
        <li>谨慎地覆盖 clone</li>
        <li>考虑实现 Comparable 接口</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>类和接口</td>
    <td>
      <ul>
        <li>使类和成员的可访问性最小化</li>
        <li>要在公有类而非公有域中使用访问方法</li>
        <li>使可变性最小化</li>
        <li>复合优先于继承</li>
        <li>要么设计继承并提供文档说明，要么禁止继承</li>
        <li>接口优于抽象类</li>
        <li>为后代设计接口</li>
        <li>接口只用于定义类型</li>
        <li>类层次优于标签类</li>
        <li>静态成员类优于非静态成员类</li>
        <li>限制源文件为单个顶级类</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>泛型</td>
    <td>
      <ul>
        <li>请不要使用原生态类型</li>
        <li>消除非受检的警告</li>
        <li>列表优于数组</li>
        <li>优先考虑泛型</li>
        <li>优先考虑泛型方法</li>
        <li>利用有限制通配符来提升API的灵活性</li>
        <li>谨慎并用泛型和可变参数</li>
        <li>优先考虑类型安全的异构容器</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>枚举和注解</td>
    <td>
      <ul>
        <li>用 enum 代替 int 常量</li>
        <li>用实例域代替序数</li>
        <li>用 EnumSet 代替位域</li>
        <li>用 EnumMap 代替序数索引</li>
        <li>用接口模拟可扩展的枚举</li>
        <li>注解优先于命名模式</li>
        <li>坚持使用 Override 注解</li>
        <li>用标记接口定义类型</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Lambda 和 Stream</td>
    <td>
      <ul>
        <li>Lambda 优先于匿名类</li>
        <li>坚持使用标准的函数接口</li>
        <li>谨慎使用 Stream</li>
        <li>优先选择 Stream 中无副作用的函数</li>
        <li>Stream 要优先用 Collection 作为返回类型</li>
        <li>谨慎使用 Stream 并行</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>方法</td>
    <td>
      <ul>
        <li>检查参数的有效性</li>
        <li>必要时进行保护性拷贝</li>
        <li>谨慎设计方法签名</li>
        <li>慎用重载</li>
        <li>慎用可变参数</li>
        <li>返回零长度的数组或者集合，而不是 null</li>
        <li>谨慎返回 optinal</li>
        <li>为所有导出的 API 元素编写文档注释</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>通用编程</td>
    <td>
      <ul>
        <li>将局部变量的作用域最小化</li>
        <li>for-each 循环优先于传统的 for 循环</li>
        <li>了解和使用类库</li>
        <li>如果需要精确的答案，请避免使用 float 和 double</li>
        <li>基本类型优先于装箱基本类型</li>
        <li>如果其他类型更适合，则尽量避免使用字符串</li>
        <li>了解字符串连接的性能</li>
        <li>通过接口引用对象</li>
        <li>接口优先于反射机制</li>
        <li>谨慎地使用本地方法</li>
        <li>谨慎地进行优化</li>
        <li>遵守普遍接受的命名惯例</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>异常</td>
    <td>
      <ul>
        <li>只针对异常的情况才使用异常</li>
        <li>对可恢复的情况使用受检异常，对编程错误使用运行时异常</li>
        <li>避免不必要地使用受检异常</li>
        <li>优先使用标准的异常</li>
        <li>抛出与抽象对应的异常</li>
        <li>每个方法抛出的所有异常都要建立文档</li>
        <li>在细节消息中包含失败-捕获信息</li>
        <li>努力使失败保持原子性</li>
        <li>不要忽略异常</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>并发</td>
    <td>
      <ul>
        <li>同步访问共享的可变数据</li>
        <li>避免过度同步</li>
        <li>executor、task和stream优先于线程</li>
        <li>并发工具优先于wait和notify</li>
        <li>线程安全性的文档化</li>
        <li>慎用延迟初始化</li>
        <li>不要依赖于线程调度器</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>序列化</td>
    <td>
      <ul>
        <li>其他方法优先于Java序列化</li>
        <li>谨慎地实现Serializable接口</li>
        <li>考虑使用自定义的序列化形式</li>
        <li>保护性地编写readObject方法</li>
        <li>对于实例控制，枚举类型优先于readResolve</li>
        <li>考虑用序列化代理代替序列化实例</li>
      </ul>
    </td>
  </tr>
</table>


<br/>

Java并发编程实战
<table>
  <tr>
    <td>简介</td>
    <td>
      <ul>
        <li>并发简史 </li>
        <li>线程的优势 </li>
        <li>线程带来的风险</li>
        <li>线程无处不在</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>线程安全性 </td>
    <td>
      <ul>
        <li>什么是线程安全性</li>
        <li>原子性</li>
        <li>加锁机制</li>
        <li>用锁来保护状态</li>
        <li>活跃性与性能</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>对象的共享</td>
    <td>
      <ul>
        <li>可见性</li>
        <li>发布与逸出</li>
        <li>线程封闭</li>
        <li>不变性</li>
        <li>安全发布</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>对象的组合</td>
    <td>
      <ul>
        <li>设计线程安全的类</li>
        <li>实例封闭</li>
        <li>线程安全性的委托</li>
        <li>在现有的线程安全类中添加功能</li>
        <li>将同步策略文档化</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>基础构建模块</td>
    <td>
      <ul>
        <li>同步容器类</li>
        <li>并发容器</li>
        <li>阻塞队列和生产者-消费者模式</li>
        <li>阻塞方法与中断方法</li>
        <li>同步工具类</li>
        <li>构建高效且可伸缩的结果缓存</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>任务执行</td>
    <td>
      <ul>
        <li>在线程中执行任务</li>
        <li>Executor框架</li>
        <li>找出可利用的并行性</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>取消与关闭</td>
    <td>
      <ul>
        <li></li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>线程池的使用</td>
    <td>
      <ul>
        <li></li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>图形用户界面应用程序</td>
    <td>
      <ul>
        <li></li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>避免活跃性危险</td>
    <td>
      <ul>
        <li></li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>性能与可伸缩性</td>
    <td>
      <ul>
        <li></li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>并发程序的测试</td>
    <td>
      <ul>
        <li></li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>显式锁</td>
    <td>
      <ul>
        <li></li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>构建自定义的同步工具</td>
    <td>
      <ul>
        <li></li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>原子变量与非阻塞同步机制</td>
    <td>
      <ul>
        <li></li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Java内存模型</td>
    <td>
      <ul>
        <li></li>
      </ul>
    </td>
  </tr>
</table>

<br/>

Kotlin从零到精通Android开发
<table>
  <tr>
    <td>搭建Kotlin开发环境</td>
    <td>
      <ul>
        <li>Kotlin与Android开发的关系</li>
        <li>Kotlin开发工具</li>
        <li>SDK安装与插件升级</li>
        <li>Kotlin简单配置</li>
        <li>Kotlin相关技术</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>数据类型</td>
    <td>
      <ul>
        <li>基本数据类型</li>
        <li>数组</li>
        <li>字符串</li>
        <li>容器</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>控制语句</td>
    <td>
      <ul>
        <li>条件分支</li>
        <li>循环处理</li>
        <li>空安全</li>
        <li>等式判断</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>函数运用</td>
    <td>
      <ul>
        <li>函数的基本用法</li>
        <li>输入参数的变化</li>
        <li>几种特殊函数</li>
        <li>增强系统函数</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>类和对象</td>
    <td>
      <ul>
        <li>类的构造</li>
        <li>类的成员</li>
        <li>类的继承</li>
        <li>几种特殊类</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Kotlin使用简单控件</td>
    <td>
      <ul>
        <li>使用按钮控件</li>
        <li>使用页面布局</li>
        <li>使用图文控件</li>
        <li>Activity活动跳转</li>
        <li>实战项目：电商App的登录页面</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Kotlin操纵复杂控件</td>
    <td>
      <ul>
        <li>使用视图排列</li>
        <li>使用材质设计MaterialDesign</li>
        <li>实现页面切换</li>
        <li>广播收发Broadcast</li>
        <li>实战项目：电商App的商品频道</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Kotlin进行数据存储</td>
    <td>
      <ul>
        <li>使用共享参数SharedPreferences</li>
        <li>使用数据库SQLite</li>
        <li>文件I/O操作</li>
        <li>Application全局变量</li>
        <li>实战项目：电商App的购物车</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Kotlin自定义控件</td>
    <td>
      <ul>
        <li>自定义普通视图</li>
        <li>自定义简单动画</li>
        <li>自定义通知栏</li>
        <li>Service服务启停</li>
        <li>实战项目：电商App的生鲜团购</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Kotlin实现网络通信</td>
    <td>
      <ul>
        <li>多线程技术</li>
        <li>访问HTTP接口</li>
        <li>文件下载操作</li>
        <li>ContentProvider内容提供</li>
        <li>实战项目：电商App的自动升级</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

Android应用开发进阶
<table>
  <tr>
    <td>自定义控件</td>
    <td>
      <ul>
        <li>View的绘制流程</li>
        <li>View的触摸事件</li>
        <li>自定义控件常用方法总结</li>
        <li>自定义控件案例</li>
        <li>自定义控件性能优化</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>轮子</td>
    <td>
      <ul>
        <li>AppBrain平台</li>
        <li>Butter Knife</li>
        <li>EventBus</li>
        <li>Dagger2</li>
        <li>OkHttp</li>
        <li>Retrofit</li>
        <li>Volley</li>
        <li>RxJava</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Android应用架构</td>
    <td>
      <ul>
        <li>todo-mvp</li>
        <li>todo-mvp-clean</li>
        <li>todo-mvp-dagger</li>
        <li>todo-mvp-rxjava</li>
        <li>todo-mvvm-databinding</li>
        <li>todo-mvvm-live</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>AndroidPlus项目实战</td>
    <td>
      <ul>
        <li>需求分析</li>
        <li>产品设计</li>
        <li>Java实现</li>
        <li>Kotlin实现</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>开发实践</td>
    <td>
      <ul>
        <li>Android Studio中的Git实践</li>
        <li>Android屏幕适配</li>
        <li>Android视频播放器</li>
        <li>声网直播实践</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

RxJava 2.x 实战
<table>
  <tr>
    <td>RxJava 简介</td>
    <td>
      <ul>
        <li>你需要了解的函数响应式编程</li>
        <li>RxJava 简介</li>
        <li>为何选择RxJava</li>
        <li>RxJava 能做什么</li>
        <li>RxJava 2 的 Hello World</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>RxJava 基础知识</td>
    <td>
      <ul>
        <li>Observable</li>
        <li>Hot Observable 和Cold Observable</li>
        <li>Flowable</li>
        <li>Single、Completable 和 Maybe</li>
        <li>Subject 和 Processor</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>创建操作符</td>
    <td>
      <ul>
        <li>create、just 和 from</li>
        <li>repeat</li>
        <li>defer、interval 和 timer</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>RxJava 的线程操作</td>
    <td>
      <ul>
        <li>调度器（Scheduler）种类</li>
        <li>RxJava 线程模型</li>
        <li>Scheduler 的测试</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>变换操作和过滤操作符</td>
    <td>
      <ul>
        <li>map 和 flatMap</li>
        <li>groupBy</li>
        <li>buffer 和 window</li>
        <li>first 和 last</li>
        <li>take 和 takeLast</li>
        <li>skip 和 skipLast</li>
        <li>elementAt 和 ignoreElements</li>
        <li>distinct 和 filter</li>
        <li>debounce</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>条件操作符和布尔操作符</td>
    <td>
      <ul>
        <li>all、contains 和 amb</li>
        <li>defaultIfEmpty</li>
        <li>sequenceEqual</li>
        <li>skipUtil 和 skipWhile</li>
        <li>takeUtil 和 takeWhile</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>合并操作符与连接操作符</td>
    <td>
      <ul>
        <li>merge 和zip</li>
        <li>combineLatest 和 join</li>
        <li>startWith</li>
        <li>connect、push 和 refCount</li>
        <li>replay</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>RxJava 的背压</td>
    <td>
      <ul>
        <li>背压</li>
        <li>RxJava 2.x 的背压策略</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Disposble 和 Transformer 的使用</td>
    <td>
      <ul>
        <li>Disposable</li>
        <li>RxLifecycle 和 AutoDispose</li>
        <li>Transformer 在 RxJava 中的使用</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>RxJava 的并行编程</td>
    <td>
      <ul>
        <li>RxJava 并行操作</li>
        <li>ParallelFlowable</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>RxBinding 的使用</td>
    <td>
      <ul>
        <li>RxBinding 简介</li>
        <li>RxBinding 使用场景</li>
        <li>RxBinding 结合 RxPermissions 的使用</li>
        <li>RxBinding 使用的注意点</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>RxAndroid 2.x 和 Retrofit 的使用</td>
    <td>
      <ul>
        <li>RxAndroid 2.x 简介</li>
        <li>Retrofit 简介</li>
        <li>Retrofit 与 RxJava 的完美配合</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>开发EventBus</td>
    <td>
      <ul>
        <li>传统的EventBus</li>
        <li>开发一个新的EventBus（一）</li>
        <li>开发一个新的EventBus（二）</li>
        <li>开发一个新的EventBus（三）</li>
        <li>开发一个新的EventBus（四）</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>使用 RxJava 封装 Httpclient</td>
    <td>
      <ul>
        <li>HttpClient 的介绍</li>
        <li>使用RxJava 进行重构</li>
        <li>实现一个简单的图片爬虫</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Spring Boot 和RxJava 2</td>
    <td>
      <ul>
        <li>模拟Task 任务</li>
        <li>构建一个给爬虫使用的代理 IP 池</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Java 8 的函数式编程</td>
    <td>
      <ul>
        <li>Java 8 的新变化</li>
        <li>函数</li>
        <li>Lambda 表达式</li>
        <li>Java 8 新增的Stream</li>
        <li>函数的柯里化</li>
        <li>新的异步编程方式CompletableFuture</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Kotin 和RxJava</td>
    <td>
      <ul>
        <li>Kotlin 简介</li>
        <li>使用Kotlin 来封装图像框架</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>展望未来</td>
    <td>
      <ul>
        <li>期待已久的Java 9</li>
        <li>其他的Reactive Streams 项目</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

音视频开发进阶指南：基于Android与iOS平台的实践
<table>
  <tr>
    <td>音视频基础概念</td>
    <td>
      <ul>
        <li>声音的物理性质</li>
        <li>数字音频</li>
        <li>音频编码</li>
        <li>图像的物理现象</li>
        <li>图像的数值表示</li>
        <li>视频的编码方式</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>移动端环境搭建</td>
    <td>
      <ul>
        <li>在iOS上如何搭建一个基础项目</li>
        <li>在Android上如何搭建一个基础项目</li>
        <li>交叉编译的原理与实践</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>FFmpeg的介绍与使用</td>
    <td>
      <ul>
        <li>FFmpeg的编译与命令行工具的使用</li>
        <li>FFmpeg API的介绍与使用</li>
        <li>FFmpeg源码结构</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>移动平台下的音视频渲染</td>
    <td>
      <ul>
        <li>AudioUnit介绍与实践</li>
        <li>Android平台的音频渲染</li>
        <li>视频渲染</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>实现一款视频播放器</td>
    <td>
      <ul>
        <li>架构设计</li>
        <li>解码模块的实现</li>
        <li>音频播放模块的实现</li>
        <li>画面播放模块的实现</li>
        <li>AVSync模块的实现</li>
        <li>中控系统串联起各个模块</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>音视频的采集与编码</td>
    <td>
      <ul>
        <li>音频的采集</li>
        <li>视频画面的采集</li>
        <li>音频的编码</li>
        <li>视频画面的编码</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>实现一款视频录制应用</td>
    <td>
      <ul>
        <li>视频录制的架构设计</li>
        <li>音频模块的实现</li>
        <li>音频编码模块的实现</li>
        <li>画面采集与编码模块的实现</li>
        <li>Mux模块</li>
        <li>中控系统串联起各个模块</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>音频效果器的介绍与实践</td>
    <td>
      <ul>
        <li>数字音频基础</li>
        <li>数字音频处理：快速傅里叶变换</li>
        <li>基本乐理知识</li>
        <li>混音效果器</li>
        <li>效果器实现</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>视频效果器的介绍与实践</td>
    <td>
      <ul>
        <li>图像处理的基本原理</li>
        <li>图像处理进阶</li>
        <li>使用FFmpeg内部的视频滤镜</li>
        <li>使用OpenGL ES实现视频滤镜</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>专业的视频录制应用实践</td>
    <td>
      <ul>
        <li>视频硬件解码器的使用</li>
        <li>音频效果器的集成</li>
        <li>一套跨平台的视频效果器的设计与实现</li>
        <li>将特效处理库集成到视频录制项目中</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>直播应用的构建</td>
    <td>
      <ul>
        <li>直播场景分析</li>
        <li>拉流播放器的构建</li>
        <li>推流器的构建</li>
        <li>第三方云服务介绍</li>
        <li>礼物系统的实现</li>
        <li>聊天系统的实现</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>直播应用中的关键处理</td>
    <td>
      <ul>
        <li>直播应用的细节分析</li>
        <li>推流端的关键处理</li>
        <li>拉流端的关键处理</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>工欲善其事，必先利其器</td>
    <td>
      <ul>
        <li>Android平台工具详解</li>
        <li>iOS使用Instruments诊断应用</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

新时期的Node.js入门
<table>
  <tr>
    <td>基础知识</td>
    <td>
      <ul>
        <li>Node是什么</li>
        <li>Node的内部机制</li>
        <li>事件循环(Event loop)</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>常用模块</td>
    <td>
      <ul>
        <li>Module</li>
        <li>Buffer</li>
        <li>File System</li>
        <li>HTTP服务</li>
        <li>TCP服务</li>
        <li>更安全的传输方式——SSL</li>
        <li>WebSocket</li>
        <li>Stream</li>
        <li>Events</li>
        <li>多进程服务</li>
        <li>Process对象</li>
        <li>Timer</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>用ES6来书写Node</td>
    <td>
      <ul>
        <li>新时代的EMCAScript</li>
        <li>块级作用域</li>
        <li>数组</li>
        <li>函数</li>
        <li>Set和Map</li>
        <li>Iterator</li>
        <li>对象</li>
        <li>类</li>
        <li>类的继承</li>
        <li>ES6的模块化标准</li>
        <li>使用babel来转换代码</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>书写异步代码</td>
    <td>
      <ul>
        <li>异步操作的返回值</li>
        <li>组织回调方法</li>
        <li>使用Promise</li>
        <li>Generator，一种过渡方案</li>
        <li>回调的终点——async/await</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>使用Koa2构建Web站点</td>
    <td>
      <ul>
        <li>Node Web框架的发展历程</li>
        <li>内容规划</li>
        <li>Koa入门</li>
        <li>middleware</li>
        <li>常用服务的实现</li>
        <li>构建健壮的Web应用</li>
        <li>使用Redis进行持久化</li>
        <li>Koa源码剖析</li>
        <li>网站部署</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>爬虫系统的开发</td>
    <td>
      <ul>
        <li>爬虫技术概述</li>
        <li>技术栈简介</li>
        <li>构建脚手架</li>
        <li>进行批量爬取</li>
        <li>爬虫架构的改进</li>
        <li>进程架构的改进</li>
        <li>反爬虫处理</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>测试与调试</td>
    <td>
      <ul>
        <li>单元测试</li>
        <li>测试现有代码</li>
        <li>更高维度的测试</li>
        <li>调试Node应用</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Node中的错误处理</td>
    <td>
      <ul>
        <li>Error模块</li>
        <li>错误处理的几种方式</li>
        <li>被抛弃的Domain</li>
        <li>ES6中的错误处理</li>
        <li>Web服务中的错误处理</li>
        <li>防御式编程与Let it crash</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

深入浅出Webpack
<table>
  <tr>
    <td>入门</td>
    <td>
      <ul>
        <li>前端的发展</li>
        <li>常见的构建工具及对比</li>
        <li>安装Webpack</li>
        <li>使用Loader</li>
        <li>使用Plugin</li>
        <li>使用DevServer</li>
        <li>核心概念</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>配置</td>
    <td>
      <ul>
        <li>Entry</li>
        <li>Output</li>
        <li>Module</li>
        <li>Resolve</li>
        <li>Plugin</li>
        <li>DevServer</li>
        <li>其他配置项</li>
        <li>整体配置结构</li>
        <li>多种配置类型</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>实战</td>
    <td>
      <ul>
        <li>使用ES6语言</li>
        <li>使用TypeScript语言</li>
        <li>使用Flow检查器</li>
        <li>使用SCSS语言</li>
        <li>使用PostCSS</li>
        <li>使用React框架</li>
        <li>使用Vue框架</li>
        <li>使用Angular2框架</li>
        <li>为单页应用生成HTML</li>
        <li>管理多个单页应用</li>
        <li>构建同构应用</li>
        <li>构建Electron应用</li>
        <li>构建Npm模块</li>
        <li>构建离线应用</li>
        <li>搭配Npm Script</li>
        <li>检查代码</li>
        <li>通过Node.js API启动Webpack</li>
        <li>使用Webpack Dev Middleware</li>
        <li>加载图片</li>
        <li>加载SVG</li>
        <li>加载Source Map</li>
        <li>实战总结</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>优化</td>
    <td>
      <ul>
        <li>缩小文件的搜索范围</li>
        <li>使用DllPlugin</li>
        <li>使用HappyPack</li>
        <li>使用ParallelUglifyPlugin</li>
        <li>使用自动刷新</li>
        <li>开启模块热替换</li>
        <li>区分环境</li>
        <li>压缩代码</li>
        <li>CDN加速</li>
        <li>使用Tree Shaking</li>
        <li>提取公共代码</li>
        <li>分割代码以按需加载</li>
        <li>使用Prepack</li>
        <li>开启Scope Hoisting</li>
        <li>输出分析</li>
        <li>优化总结</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>原理</td>
    <td>
      <ul>
        <li>工作原理概括</li>
        <li>输出文件分析</li>
        <li>编写Loader</li>
        <li>编写Plugin</li>
        <li>调试Webpack</li>
        <li>原理总结</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

App后台开发运维和架构实践
<table>
  <tr>
    <td>App后台入门</td>
    <td>
      <ul>
        <li>App后台的功能</li>
        <li>App后台架构</li>
        <li>App和App后台的通信</li>
        <li>App后台和Web后端的区别</li>
        <li>选择服务器</li>
        <li>选择编程语言</li>
        <li>快速入门新技术</li>
        <li>App是怎样炼成的</li>
        <li>最适合App的开发模式——敏捷开发</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>App后台基础技术</td>
    <td>
      <ul>
        <li>从App业务逻辑中提炼API接口</li>
        <li>设计API的要点</li>
        <li>如何选择合适的数据库产品</li>
        <li>如何选择消息队列软件</li>
        <li>使用分布式服务实现业务的复用</li>
        <li>搜索技术入门</li>
        <li>定时任务</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>App后台核心技术</td>
    <td>
      <ul>
        <li>用户验证方案</li>
        <li>App通信安全</li>
        <li>短信服务</li>
        <li>处理表情的一些技巧</li>
        <li>高效更新数据</li>
        <li>图片处理</li>
        <li>视频处理</li>
        <li>获取APK和IPA文件里的资源</li>
        <li>文件系统</li>
        <li>ELK日志分析平台</li>
        <li>Docker构建一致的开发环境</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Linux——App后台应用最广泛的系统</td>
    <td>
      <ul>
        <li>基本的系统优化</li>
        <li>常用的命令</li>
        <li>故障案例分析</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Nginx——App后台HTTP服务的利器</td>
    <td>
      <ul>
        <li>简介</li>
        <li>基本原理</li>
        <li>常用配置</li>
        <li>性能统计</li>
        <li>实现负载均衡的方案</li>
        <li>用Nginx处理业务逻辑</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>MySQL——App后台最常用的数据库</td>
    <td>
      <ul>
        <li>基本架构</li>
        <li>选择版本</li>
        <li>配置文件详解</li>
        <li>软件优化</li>
        <li>硬件优化</li>
        <li>架构优化</li>
        <li>SQL慢查询分析</li>
        <li>云数据库简介</li>
        <li>灵活的存储结构</li>
        <li>故障排除案例</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Redis——App后台高性能的缓存系统</td>
    <td>
      <ul>
        <li>Redis简介</li>
        <li>Redis的常用数据结构及应用场景</li>
        <li>内存优化</li>
        <li>集群</li>
        <li>持久化</li>
        <li>故障排除案例</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>MongoDB——App后台新兴的数据库</td>
    <td>
      <ul>
        <li>简介</li>
        <li>核心机制解析</li>
        <li>入门</li>
        <li>高可用集群</li>
        <li>LBS——地理位置查询</li>
        <li>MongoDB 3.0版本的改进</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>App后台架构剖析</td>
    <td>
      <ul>
        <li>聊天App后台架构</li>
        <li>社交App后台架构</li>
        <li>LBS App后台架构</li>
        <li>推送服务器后台架构</li>
        <li>获得更多App后台架构资料</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>App后台架构的演进</td>
    <td>
      <ul>
        <li>架构的核心要素</li>
        <li>架构选型的要点</li>
        <li>架构的演进</li>
        <li>架构的特点</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

深入理解Android自动化测试
<table>
  <tr>
    <td>Android自动化测试基础</td>
    <td>
      <ul>
        <li>Android自动化分析</li>
        <li>什么样的兵器称手</li>
        <li>如何耍好你手上的兵器</li>
        <li>你了解你的兵器吗</li>
        <li>如何改造你的兵器</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>稳定性测试利器monkey使用详解</td>
    <td>
      <ul>
        <li>monkey概述</li>
        <li>第一个Impossible Mission</li>
        <li>monkey的基本使用</li>
        <li>monkey的命令及其使用</li>
        <li>第二个Impossible Mission</li>
        <li>monkey脚本编写</li>
        <li>monkey工具总结</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>monkey之子monkeyrunner使用详解</td>
    <td>
      <ul>
        <li>monkeyrunner概述</li>
        <li>monkeyrunner API详解</li>
        <li>monkeyrunner脚本编写</li>
        <li>第三个Impossible Mission</li>
        <li>monkeyrunner的录制回放</li>
        <li>monkeyrunner工具总结</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>单元测试框架Instrumentation使用详解</td>
    <td>
      <ul>
        <li>Instrumentation概述</li>
        <li>Instrumentation基础</li>
        <li>第四个Impossible Mission</li>
        <li>Instrumentation的前世：单元测试基础框架JUnit</li>
        <li>第五个Impossible Mission</li>
        <li>Instrumentation的今生：对Android系统的高度控制</li>
        <li>Instrumentation前世今生分析</li>
        <li>第六个Impossible Mission</li>
        <li>Instrumentation自动化脚本开发</li>
        <li>Instrumentation工具总结</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>终极自动化框架UIAutomator使用详解</td>
    <td>
      <ul>
        <li>UIAutomator概述</li>
        <li>第七个Impossible Mission</li>
        <li>更清晰的控件捕获</li>
        <li>更直观的测试项目创建</li>
        <li>UIAutomator API详解</li>
        <li>更简洁的脚本撰写</li>
        <li>更便捷地编译运行</li>
        <li>UIAutomator工具总结</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>兼容性测试框架CTS使用详解</td>
    <td>
      <ul>
        <li>CTS概述</li>
        <li>CTS测试须知</li>
        <li>CTS的命令及运行</li>
        <li>CTS测试报告</li>
        <li>CTS Verif?ier</li>
        <li>CTS注意事项</li>
        <li>CTS工具总结</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Android自动化工具使用总结</td>
    <td>
      <ul>
        <li></li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>monkey原理分析</td>
    <td>
      <ul>
        <li>monkey源码结构</li>
        <li>monkey架构分析</li>
        <li>monkey的原理总结</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>monkeyrunner原理分析</td>
    <td>
      <ul>
        <li>monkeyrunner源码结构</li>
        <li>monkeyrunner架构分析</li>
        <li>monkeyrunner的原理总结</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Instrumentation原理分析</td>
    <td>
      <ul>
        <li>Instrumentation源码结构</li>
        <li>Instrumentation架构分析</li>
        <li>Instrumentation的原理总结</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>UIAutomator原理分析</td>
    <td>
      <ul>
        <li>UIAutomator源码结构</li>
        <li>UIAutomator架构分析</li>
        <li>UIAutomator的原理总结</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>CTS原理分析</td>
    <td>
      <ul>
        <li>CTS源码结构</li>
        <li>CTS架构分析</li>
        <li>CTS的原理总结</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Android自动化工具源码总结</td>
    <td>
      <ul>
        <li></li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>从monkey到传参或录制工具开发</td>
    <td>
      <ul>
        <li>从monkey原理说开来</li>
        <li>monkey传参小工具</li>
        <li>monkey脚本录制工具开发</li>
        <li>monkey工具总结</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>从Instrumentation到稳定自动化工具开发</td>
    <td>
      <ul>
        <li>为何要做二次封装</li>
        <li>如何做Instrumentation的二次封装</li>
        <li>二次封装改进项总结</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>从UIAutomatorViewer到PC端脚本录制工具开发</td>
    <td>
      <ul>
        <li>从UIAutomatorViewer原理说开来</li>
        <li>基于UIAutomatorViewer的PC端脚本录制工具</li>
        <li>UIAutomatorViewer录制工具总结</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>从CTS到定制化单元测试</td>
    <td>
      <ul>
        <li>从CTS原理说开来</li>
        <li>用CTS运行定制单元测试脚本</li>
        <li>定制单元测试脚本总结</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Android自动化实践之路</td>
    <td>
      <ul>
        <li></li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>关于工具的反思</td>
    <td>
      <ul>
        <li>关于录制/回放工具的幻想</li>
        <li>要门槛还是要适配</li>
        <li>什么样的自动化框架才是强大的框架</li>
        <li>将第七个馒头扔出窗外</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>关于测试的反思</td>
    <td>
      <ul>
        <li>自动化是一种短线投资吗</li>
        <li>难道自动化是为了替代黑盒测试</li>
        <li>衡量自动化效果的标准是Bug数吗</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>关于人的反思</td>
    <td>
      <ul>
        <li>测试脚本编写者态度问题</li>
        <li>什么人适合做自动化</li>
        <li>自动化与组织架构有没有关系</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

Kotlin核心编程
<table>
  <tr>
    <td>认识Kotlin</td>
    <td>
      <ul>
        <li>Java的发展</li>
        <li>Scala的百宝箱</li>
        <li>Kotlin—改良的Java</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>基础语法</td>
    <td>
      <ul>
        <li>不一样的类型声明</li>
        <li>val和var的使用规则</li>
        <li>高阶函数和Lambda</li>
        <li>面向表达式编程</li>
        <li>字符串的定义和操作</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>面向对象</td>
    <td>
      <ul>
        <li>类和构造方法</li>
        <li>不同的访问控制原则</li>
        <li>解决多继承问题</li>
        <li>真正的数据类</li>
        <li>从static到object</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>代数数据类型和模式匹配</td>
    <td>
      <ul>
        <li>代数数据类型</li>
        <li>模式匹配</li>
        <li>增强 Kotlin 的模式匹配</li>
        <li>用代数数据类型来抽象业务</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>类型系统</td>
    <td>
      <ul>
        <li>null引用：10亿美元的错误</li>
        <li>可空类型</li>
        <li>比Java更面向对象的设计</li>
        <li>泛型：让类型更加安全</li>
        <li>泛型的背后：类型擦除</li>
        <li>打破泛型不变</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

Java并发编程的艺术
<table>
  <tr>
    <td>并发编程的挑战</td>
    <td>
      <ul>
        <li>上下文切换</li>
        <li>死锁</li>
        <li>资源限制的挑战</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Java并发机制的底层实现原理</td>
    <td>
      <ul>
        <li>volatile的应用</li>
        <li>synchronized的实现原理与应用</li>
        <li>原子操作的实现原理</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Java内存模型</td>
    <td>
      <ul>
        <li>Java内存模型的基础</li>
        <li>重排序</li>
        <li>顺序一致性</li>
        <li>volatile的内存语义</li>
        <li>锁的内存语义</li>
        <li>final域的内存语义</li>
        <li>happensbefore</li>
        <li>双重检查锁定与延迟初始化</li>
        <li>Java内存模型综述</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Java并发编程基础</td>
    <td>
      <ul>
        <li>线程简介</li>
        <li>启动和终止线程</li>
        <li>线程间通信</li>
        <li>线程应用实例</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Java中的锁</td>
    <td>
      <ul>
        <li>Lock接口</li>
        <li>队列同步器</li>
        <li>重入锁</li>
        <li>读写锁</li>
        <li>LockSupport工具</li>
        <li>Condition接口</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Java并发容器和框架</td>
    <td>
      <ul>
        <li>ConcurrentHashMap的实现原理与使用</li>
        <li>ConcurrentLinkedQueue</li>
        <li>Java中的阻塞队列</li>
        <li>Fork/Join框架</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Java中的13个原子操作类</td>
    <td>
      <ul>
        <li>原子更新基本类型类</li>
        <li>原子更新数组</li>
        <li>原子更新引用类型</li>
        <li>原子更新字段类</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Java中的并发工具类</td>
    <td>
      <ul>
        <li>等待多线程完成的CountDownLatch</li>
        <li>同步屏障CyclicBarrier</li>
        <li>控制并发线程数的Semaphore</li>
        <li>线程间交换数据的Exchanger</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Java中的线程池</td>
    <td>
      <ul>
        <li>线程池的实现原理</li>
        <li>线程池的使用</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Executor框架</td>
    <td>
      <ul>
        <li>Executor框架简介</li>
        <li>ThreadPoolExecutor详解</li>
        <li>ScheduledThreadPoolExecutor详解</li>
        <li>FutureTask详解</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Java并发编程实践</td>
    <td>
      <ul>
        <li>生产者和消费者模式</li>
        <li>线上问题定位</li>
        <li>性能测试</li>
        <li>异步任务池</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

漫画算法：小灰的算法之旅
<table>
  <tr>
    <td>算法概述</td>
    <td>
      <ul>
        <li>算法和数据结构</li>
        <li>时间复杂度</li>
        <li>空间复杂度</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>数据结构基础</td>
    <td>
      <ul>
        <li>什么是数组</li>
        <li>什么是链表</li>
        <li>栈和队列</li>
        <li>神奇的散列表</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>树</td>
    <td>
      <ul>
        <li>树和二叉树</li>
        <li>二叉树的遍历</li>
        <li>什么是二叉堆</li>
        <li>什么是优先队列</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>排序算法</td>
    <td>
      <ul>
        <li>引言</li>
        <li>什么是冒泡排序</li>
        <li>什么是快速排序</li>
        <li>什么是堆排序</li>
        <li>计数排序和桶排序</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>面试中的算法</td>
    <td>
      <ul>
        <li>踌躇满志的小灰</li>
        <li>如何判断链表有环</li>
        <li>最小栈的实现</li>
        <li>如何求出最大公约数</li>
        <li>如何判断一个数是否为2的整数次幂</li>
        <li>无序数组排序后的最大相邻差</li>
        <li>如何用栈实现队列</li>
        <li>寻找全排列的下一个数</li>
        <li>删去k个数字后的最小值</li>
        <li>如何实现大整数相加</li>
        <li>如何求解金矿问题</li>
        <li>寻找缺失的整数</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>算法的实际应用</td>
    <td>
      <ul>
        <li>小灰上班的第1天</li>
        <li>Bitmap的巧用</li>
        <li>LRU算法的应用</li>
        <li>什么是A星寻路算法</li>
        <li>如何实现红包算法</li>
        <li>算法之路无止境</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

FFmpeg从入门到精通
<table>
  <tr>
    <td>FFmpeg简介</td>
    <td>
      <ul>
        <li>FFmpeg的定义</li>
        <li>FFmpeg的历史</li>
        <li>FFmpeg的基本组成</li>
        <li>FFmpeg的编解码工具ffmpeg</li>
        <li>FFmpeg的播放器ffplay</li>
        <li>FFmpeg的多媒体分析器ffprobe</li>
        <li>FFmpeg编译</li>
        <li>FFmpeg编码支持与定制</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>FFmpeg工具使用基础</td>
    <td>
      <ul>
        <li>ffmpeg常用命令</li>
        <li>ffprobe常用命令</li>
        <li>ffplay常用命令</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>FFmpeg 转封装</td>
    <td>
      <ul>
        <li>音视频文件转MP4格式</li>
        <li>视频文件转FLV</li>
        <li>视频文件转M3U8</li>
        <li>视频文件切片</li>
        <li>音视频文件音视频流抽取</li>
        <li>系统资源使用情况</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>FFmpeg转码</td>
    <td>
      <ul>
        <li>FFmpeg软编码H.264与H.265</li>
        <li>FFmpeg硬编解码</li>
        <li>FFmpeg输出MP3</li>
        <li>FFmpeg输出AAC</li>
        <li>系统资源使用情况</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>FFmpeg流媒体</td>
    <td>
      <ul>
        <li>FFmpeg发布与录制RTMP流</li>
        <li>FFmpeg录制RTSP流</li>
        <li>FFmpeg录制HTTP流</li>
        <li>FFmpeg录制和发布UDP / TCP流</li>
        <li>FFmpeg推多路流</li>
        <li>FFmpeg生成HDS流</li>
        <li>FFmpeg生成DASH流</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>FFmpeg滤镜使用</td>
    <td>
      <ul>
        <li>FFmpeg滤镜Filter描述格式</li>
        <li>FFmpeg为视频加水印</li>
        <li>FFmpeg生成画中画</li>
        <li>FFmpeg视频多宫格处理</li>
        <li>FFmpeg音频流滤镜操作</li>
        <li>FFmpeg音频音量探测</li>
        <li>FFmpeg为视频加字幕</li>
        <li>FFmpeg视频抠图合并</li>
        <li>FFmpeg 3D视频处理</li>
        <li>FFmpeg定时视频截图</li>
        <li>FFmpeg生成测试元数据</li>
        <li>FFmpeg对音视频倍速处理</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>FFmpeg采集设备</td>
    <td>
      <ul>
        <li>FFmpeg中Linux设备操作</li>
        <li>FFmpeg中OS X设备操作</li>
        <li>FFmpeg中Windows设备操作</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>FFmpeg接口libavformat的使用</td>
    <td>
      <ul>
        <li>音视频流封装</li>
        <li>音视频文件解封装</li>
        <li>音视频文件转封装</li>
        <li>视频截取</li>
        <li>avio内存数据操作</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>FFmpeg接口libavcodec的使用</td>
    <td>
      <ul>
        <li>FFmpeg旧接口的使用</li>
        <li>FFmpeg新接口的使用</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>FFmpeg接口libavfilter的使用</td>
    <td>
      <ul>
        <li>filtergraph和filter简述</li>
        <li>FFmpeg中预留的滤镜</li>
        <li>avfilter流程图</li>
        <li>使用滤镜加LOGO操作</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

Android全埋点解决方案
<table>
  <tr>
    <td>全埋点概述</td>
    <td>
      <ul>
        <li>Android View 类型</li>
        <li>View 绑定listener 方式</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>$AppViewScreen全埋点</td>
    <td>
      <ul>
        <li>关键技术Application.ActivityLifecycleCallbacks</li>
        <li>原理概述</li>
        <li>案例</li>
        <li>完善方案</li>
        <li>扩展采集能力</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>$AppStart、$AppEnd 全埋点方案</td>
    <td>
      <ul>
        <li>原理概述</li>
        <li>案例</li>
        <li>缺点</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>$AppClick全埋点方案1：代理 View.OnClickListener</td>
    <td>
      <ul>
        <li>关键技术</li>
        <li>原理概述</li>
        <li>案例</li>
        <li>引入DecorView</li>
        <li>引入ViewTreeObserver.OnGlobalLayoutListener</li>
        <li>扩展采集能力</li>
        <li>缺点</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>$AppClick 全埋点方案2：代理 Window.Callback</td>
    <td>
      <ul>
        <li>关键技术</li>
        <li>原理概述</li>
        <li>案例</li>
        <li>扩展采集能力</li>
        <li>缺点</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>$AppClick 全埋点方案3：代理 View.AccessibilityDelegate</td>
    <td>
      <ul>
        <li>关键技术</li>
        <li>原理概述</li>
        <li>案例</li>
        <li>扩展采集能力</li>
        <li>缺点</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>$AppClick全埋点方案4：透明层</td>
    <td>
      <ul>
        <li>原理概述</li>
        <li>案例</li>
        <li>扩展采集能力</li>
        <li>缺点</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>$AppClick全埋点方案5: AspectJ</td>
    <td>
      <ul>
        <li>关键技术</li>
        <li>原理概述</li>
        <li>案例</li>
        <li>完善方案</li>
        <li>扩展采集能力</li>
        <li>缺点</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>$AppClick全埋点方案6：ASM</td>
    <td>
      <ul>
        <li>关键技术</li>
        <li>原理概述</li>
        <li>案例</li>
        <li>完善</li>
        <li>扩展采集能力</li>
        <li>缺点</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>$AppClick全埋点方案7：Javassist</td>
    <td>
      <ul>
        <li>关键技术</li>
        <li>原理概述</li>
        <li>案例</li>
        <li>扩展采集能力</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>$AppClick全埋点方案8： AST</td>
    <td>
      <ul>
        <li>关键技术</li>
        <li>原理概述</li>
        <li>案例</li>
        <li>完善方案</li>
        <li>扩展采集能力</li>
        <li>缺点</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

Android移动性能实战
<table>
  <tr>
    <td>最容易被忽略的性能洼地</td>
    <td>
      <ul>
        <li>原理</li>
        <li>工具集</li>
        <li>案例...</li>
        <li>专项标准：磁盘</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>内存：性能优化的终结者</td>
    <td>
      <ul>
        <li>原理</li>
        <li>工具集</li>
        <li>案例...</li>
        <li>专项标准：内存</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>网络：性能优化中的不可控因素</td>
    <td>
      <ul>
        <li>原理</li>
        <li>工具集</li>
        <li>案例...</li>
        <li>专项标准：网络</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>电池：它只是结果不是原因</td>
    <td>
      <ul>
        <li>原理</li>
        <li>工具集</li>
        <li>案例...</li>
        <li>专项标准：电池</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>原理与工具集</td>
    <td>
      <ul>
        <li>原理</li>
        <li>工具集</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>流畅度：没有最流畅，只有更流畅</td>
    <td>
      <ul>
        <li>案例...</li>
        <li>专项标准：流畅度</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>响应时延：别让用户等待</td>
    <td>
      <ul>
        <li>案例...</li>
        <li>专项标准：响应时延</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>还应该知道的一些事儿</td>
    <td>
      <ul>
        <li>UI 自动化测试</li>
        <li>专项竞品测试攻略</li>
        <li>未来的未来</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

Android Gradle权威指南
<table>
  <tr>
    <td>Gradle入门</td>
    <td>
      <ul>
        <li>配置Gradle环境</li>
        <li>Gradle版Hello World</li>
        <li>Gradle Wrapper</li>
        <li>Gradle日志</li>
        <li>Gradle命令行</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Groovy基础</td>
    <td>
      <ul>
        <li>字符串</li>
        <li>集合</li>
        <li>方法</li>
        <li>JavaBean</li>
        <li>闭包</li>
        <li>DSL</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Gradle构建脚本基础</td>
    <td>
      <ul>
        <li>Settings文件</li>
        <li>Build文件</li>
        <li>Projects以及tasks</li>
        <li>创建一个任务</li>
        <li>任务依赖</li>
        <li>任务间通过API控制、交互</li>
        <li>自定义属性</li>
        <li>脚本即代码，代码也是脚本</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Gradle任务</td>
    <td>
      <ul>
        <li>多种方式创建任务</li>
        <li>多种方式访问任务</li>
        <li>任务分组和描述</li>
        <li>操作符</li>
        <li>任务的执行分析</li>
        <li>任务排序</li>
        <li>任务的启用和禁用</li>
        <li>任务的onlyIf断言</li>
        <li>任务规则</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Gradle插件</td>
    <td>
      <ul>
        <li>插件的作用</li>
        <li>如何应用一个插件</li>
        <li>自定义插件</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Java Gradle插件</td>
    <td>
      <ul>
        <li>如何应用</li>
        <li>Java插件约定的项目结构</li>
        <li>如何配置第三方依赖</li>
        <li>如何构建一个Java项目</li>
        <li>源码集合(SourceSet)概念</li>
        <li>Java插件添加的任务</li>
        <li>Java插件添加的属性</li>
        <li>多项目构建</li>
        <li>如何发布构件</li>
        <li>生成Idea和Eclipse配置</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Android Gradle插件</td>
    <td>
      <ul>
        <li>Android Gradle插件简介</li>
        <li>Android Gradle插件分类</li>
        <li>应用Android Gradle插件</li>
        <li>Android Gradle工程示例</li>
        <li>Android Gradle任务</li>
        <li>从Eclipse迁移到Android Gradle工程</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>自定义Android Gradle工程</td>
    <td>
      <ul>
        <li>defaultConfig默认配置</li>
        <li>配置签名信息</li>
        <li>构建的应用类型</li>
        <li>使用混淆</li>
        <li>启用zipalign优化</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Android Gradle高级自定义</td>
    <td>
      <ul>
        <li>使用共享库</li>
        <li>批量修改生成的apk文件名</li>
        <li>动态生成版本信息</li>
        <li>隐藏签名文件信息</li>
        <li>动态配置AndroidManifest文件</li>
        <li>自定义你的BuildConfig</li>
        <li>动态添加自定义的资源</li>
        <li>Java编译选项</li>
        <li>adb操作选项配置</li>
        <li>DEX选项配置</li>
        <li>突破65535方法限制</li>
        <li>自动清理未使用的资源</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Android Gradle多项目构建</td>
    <td>
      <ul>
        <li>Android项目区别</li>
        <li>Android多项目设置</li>
        <li>库项目引用和配置</li>
        <li>库项目单独发布</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Android Gradle多渠道构建</td>
    <td>
      <ul>
        <li>多渠道构建的基本原理</li>
        <li>Flurry多渠道和友盟多渠道构建</li>
        <li>多渠道构建定制</li>
        <li>提高多渠道构建的效率</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Android Gradle测试</td>
    <td>
      <ul>
        <li>基本概念</li>
        <li>本地单元测试</li>
        <li>Instrument测试</li>
        <li>测试选项配置</li>
        <li>代码覆盖率</li>
        <li>Lint支持</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Android Gradle NDK支持</td>
    <td>
      <ul>
        <li>环境配置</li>
        <li>编译C/C 源代码</li>
        <li>多平台编译</li>
        <li>使用第三方的so库</li>
        <li>使用NDK提供的库</li>
        <li>C 库支持</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Android Gradle持续集成</td>
    <td>
      <ul>
        <li>什么是持续集成</li>
        <li>持续集成的价值</li>
        <li>Android Gradle持续集成</li>
        <li>怎样更好地做持续集成</li>
        <li>人才是关键</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

JavaScript忍者秘籍 第2版
<table>
  <tr>
    <td>无处不在的 JavaScript</td>
    <td>
      <ul>
        <li>“理解”JavaScript语言</li>
        <li>理解浏览器</li>
        <li>使用当前的最佳实践</li>
        <li>提高跨平台开发能力</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>运行时的页面构建过程</td>
    <td>
      <ul>
        <li>生命周期概览</li>
        <li>页面构建阶段</li>
        <li>事件处理</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>新手的第一堂函数课：定义与参数</td>
    <td>
      <ul>
        <li>函数式的不同点到底是什么</li>
        <li>函数作为对象的乐趣</li>
        <li>函数定义</li>
        <li>函数的实参和形参</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>函数进阶：理解函数</td>
    <td>
      <ul>
        <li>使用隐式函数参数</li>
        <li>函数调用</li>
        <li>解决函数上下文的问题</li>
        <li></li>
        <li></li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>精通函数：闭包和作用域</td>
    <td>
      <ul>
        <li>理解闭包</li>
        <li>使用闭包</li>
        <li>通过执行上下文来跟踪代码</li>
        <li>使用词法环境跟踪变量的作用域</li>
        <li>理解JavaScript的变量类型</li>
        <li>研究闭包的工作原理</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>未来的函数：生成器和 Promise</td>
    <td>
      <ul>
        <li>使用生成器和promise编写优雅的异步代码</li>
        <li>使用生成器函数</li>
        <li>使用promise</li>
        <li>把生成器和promise相结合</li>
        <li></li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>面向对象与原型</td>
    <td>
      <ul>
        <li>理解原型</li>
        <li>对象构造器与原型</li>
        <li>实现继承</li>
        <li>在ES6使用JavaScript的class</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>控制对象的访问</td>
    <td>
      <ul>
        <li>使用getter与setter控制属性访问</li>
        <li>使用代理控制访问</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>处理集合</td>
    <td>
      <ul>
        <li>数组</li>
        <li>Map</li>
        <li>Set</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>正则表达式</td>
    <td>
      <ul>
        <li>为什么需要正则表达式</li>
        <li>正则表达式进阶</li>
        <li>编译正则表达式</li>
        <li>捕获匹配的片段</li>
        <li>利用函数进行替换</li>
        <li>使用正则表达式解决常见的问题</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>代码模块化</td>
    <td>
      <ul>
        <li>在JavaScript ES6之前的版本中模块化代码</li>
        <li>ES6模块</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>DOM操作</td>
    <td>
      <ul>
        <li>向DOM中注入HTML</li>
        <li>DOM的特性和属性</li>
        <li>令人头疼的样式特性</li>
        <li>避免布局抖动</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>历久弥新的事件</td>
    <td>
      <ul>
        <li>深入事件循环</li>
        <li>玩转计时器：延迟执行和间隔执行</li>
        <li>处理事件</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>跨浏览器开发</td>
    <td>
      <ul>
        <li>跨浏览器注意事项</li>
        <li>五大开发问题</li>
        <li>实现策略</li>
        <li>减少假设</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

Git高手之路
<table>
  <tr>
    <td>Git应用入门</td>
    <td>
      <ul>
        <li>版本控制与Git</li>
        <li>Git简易示例</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>项目历史管理</td>
    <td>
      <ul>
        <li>有向无环图</li>
        <li>修订内部查询</li>
        <li>修订区间查询</li>
        <li>历史记录查询</li>
        <li>单个文件历史记录</li>
        <li>使用git bisect命令查找bug</li>
        <li>日志的查询和格式化输出</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>使用Git进行程序开发</td>
    <td>
      <ul>
        <li>新建提交</li>
        <li>使用分支</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>工作区管理</td>
    <td>
      <ul>
        <li>忽略文件</li>
        <li>文件属性</li>
        <li>使用reset命令修复错误</li>
        <li>隐藏暂存变更</li>
        <li>管理工作区和暂存区</li>
        <li>多工作目录</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Git协作开发</td>
    <td>
      <ul>
        <li>协作工作流</li>
        <li>远程版本库管理</li>
        <li>传输协议</li>
        <li>发布变更到上游</li>
        <li>信任链</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>分支应用进阶</td>
    <td>
      <ul>
        <li>分支的类型和用途</li>
        <li>分支工作流和发布工程</li>
        <li>远程版本库上分支间的交互</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>集成变更</td>
    <td>
      <ul>
        <li>集成变更的方法</li>
        <li>解决合并冲突</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>历史记录管理</td>
    <td>
      <ul>
        <li>Git内部机制简介</li>
        <li>重写修订历史</li>
        <li>历史记录的非重写式编辑</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>子项目管理—构建活动框架</td>
    <td>
      <ul>
        <li>管理库和框架的依赖</li>
        <li>大型Git版本库管理</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Git的定制和扩展</td>
    <td>
      <ul>
        <li>Git与命令行</li>
        <li>图形化接口</li>
        <li>配置Git</li>
        <li>Git自动化钩子</li>
        <li>Git扩展</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Git日常管理</td>
    <td>
      <ul>
        <li>版本库维护</li>
        <li>数据恢复和故障诊断</li>
        <li>Git服务端配置</li>
        <li>改进开发工作流</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Git最佳实践</td>
    <td>
      <ul>
        <li>启动项目</li>
        <li>推进项目</li>
        <li>集成变更</li>
        <li>其他注意事项</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

Android组件化架构
<table>
  <tr>
    <td>组件化基础</td>
    <td>
      <ul>
        <li>你知道组件化吗</li>
        <li>基础组件化架构介绍</li>
        <li>重新认识AndroidManifest</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>组件化编程</td>
    <td>
      <ul>
        <li>本地广播</li>
        <li>组件间通信机制</li>
        <li>组件间跳转</li>
        <li>动态创建</li>
        <li>数据存储</li>
        <li>权限管理</li>
        <li>静态常量</li>
        <li>资源冲突</li>
        <li>组件化混淆</li>
        <li>多渠道模块</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>组件化优化</td>
    <td>
      <ul>
        <li>Gradle优化</li>
        <li>Git组件化部署</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>组件化编译</td>
    <td>
      <ul>
        <li>Gradle编译</li>
        <li>极速增量编译</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>组件化分发</td>
    <td>
      <ul>
        <li>Activity分发</li>
        <li>Fragment分发</li>
        <li>View分发</li>
        <li>依赖倒置</li>
        <li>组件化列表配置</li>
        <li>加载优化</li>
        <li>层级限制</li>
        <li>多模板设计</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>组件化流通</td>
    <td>
      <ul>
        <li>内部流通</li>
        <li>组件化SDK</li>
        <li>JCenter共享</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>架构模板</td>
    <td>
      <ul>
        <li>组件化模板</li>
        <li>注解检测</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>架构演化</td>
    <td>
      <ul>
        <li>基础架构</li>
        <li>基础组件化</li>
        <li>模块化</li>
        <li>多模板化</li>
        <li>插件化</li>
        <li>进程化</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

React进阶之路
<table>
  <tr>
    <td>初识React</td>
    <td>
      <ul>
        <li>React简介</li>
        <li>ES 6语法简介 </li>
        <li>开发环境及工具介绍</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>React基础</td>
    <td>
      <ul>
        <li>JSX</li>
        <li>组件</li>
        <li>组件的生命周期</li>
        <li>列表和Keys</li>
        <li>事件处理</li>
        <li>表单</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>React 16新特性</td>
    <td>
      <ul>
        <li>render新的返回类型</li>
        <li>错误处理</li>
        <li>Portals</li>
        <li>自定义DOM属性</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>深入理解组件</td>
    <td>
      <ul>
        <li>组件state</li>
        <li>组件与服务器通信</li>
        <li>组件通信</li>
        <li>特殊的ref</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>虚拟DOM和性能优化</td>
    <td>
      <ul>
        <li>虚拟DOM</li>
        <li>Diff算法</li>
        <li>性能优化</li>
        <li>性能检测工具</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>高阶组件</td>
    <td>
      <ul>
        <li>基本概念</li>
        <li>使用场景</li>
        <li>参数传递</li>
        <li>继承方式实现高阶组件</li>
        <li>注意事项</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>路由：用ReactRouter开发单页面应用</td>
    <td>
      <ul>
        <li>基本用法</li>
        <li>项目实战</li>
        <li>代码分片</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Redux：可预测的状态管理机</td>
    <td>
      <ul>
        <li>简介</li>
        <li>主要组成</li>
        <li>在React中使用Redux</li>
        <li>中间件与异步操作</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Redux项目实战</td>
    <td>
      <ul>
        <li>组织项目结构</li>
        <li>设计state</li>
        <li>设计模块</li>
        <li>连接Redux</li>
        <li>Redux调试工具</li>
        <li>性能优化</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>MobX：简单可扩展的状态管理解决方案</td>
    <td>
      <ul>
        <li>简介</li>
        <li>主要组成</li>
        <li>MobX响应的常见误区</li>
        <li>在React中使用MobX</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>MobX项目实战</td>
    <td>
      <ul>
        <li>组织项目结构</li>
        <li>设计store</li>
        <li>视图层重构</li>
        <li>MobX调试工具</li>
        <li>优化建议</li>
        <li>Redux与MobX比较</li>
      </ul>
    </td>
  </tr>
</table>

<br/>

深入探索Android热修复技术原理
<table>
  <tr>
    <td>热修复技术介绍</td>
    <td>
      <ul>
        <li>什么是热修复</li>
        <li>基本概念</li>
        <li>技术积淀</li>
        <li>技术概览</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>热替换代码修复</td>
    <td>
      <ul>
        <li>底层热替换原理</li>
        <li>突破底层差异的方法</li>
        <li>编译期与语言特性的影响</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>冷启动代码修复</td>
    <td>
      <ul>
        <li>冷启动类加载原理</li>
        <li>多态对冷启动类加载的影响</li>
        <li>Dalvik 下完整dex 方案的新探索</li>
        <li>入口类与初始化时机的选择</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>资源热修复技术</td>
    <td>
      <ul>
        <li>普遍的实现方式</li>
        <li>资源文件的格式</li>
        <li>运行时资源的解析</li>
        <li>另辟蹊径的资源修复方案</li>
        <li>更优雅地替换AssetManager</li>
        <li>一个意料之外的资源问题</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>so 库热修复技术</td>
    <td>
      <ul>
        <li>so 库加载原理</li>
        <li>so 库热部署实时生效的可行性分析</li>
        <li>so 库冷部署重启生效实现方案</li>
        <li>如何正确复制补丁so 库</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>其他优秀的热修复方案</td>
    <td>
      <ul>
        <li>Dexposed 浅析</li>
        <li>AndFix 探索历程</li>
        <li>Amigo 核心解读</li>
        <li>腾讯系热修复方案简介</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>热修复技术的未来展望</td>
    <td>
      <ul>
        <li>热修复的专业性</li>
        <li>对Android 生态的影响</li>
        <li>Android 与iOS 热修复的不同</li>
        <li>未来，无限可能</li>
      </ul>
    </td>
  </tr>
</table>

<br/>
<br/>

**书籍封面**

<table>
  <tr>
    <td><img src="./res/001.png" width="200"/></td>
    <td><img src="./res/002.png" width="200"/></td>
    <td><img src="./res/003.png" width="200"/></td>
    <td><img src="./res/004.png" width="200"/></td>
  </tr>
  <tr>
    <td><img src="./res/005.png" width="200"/></td>
    <td><img src="./res/006.png" width="200"/></td>
    <td><img src="./res/007.png" width="200"/></td>
    <td><img src="./res/008.png" width="200"/></td>
  </tr>
  <tr>
    <td><img src="./res/009.png" width="200"/></td>
    <td><img src="./res/010.png" width="200"/></td>
    <td><img src="./res/011.png" width="200"/></td>
    <td><img src="./res/012.png" width="200"/></td>
  </tr>
  <tr>
    <td><img src="./res/013.png" width="200"/></td>
    <td><img src="./res/014.png" width="200"/></td>
    <td><img src="./res/015.png" width="200"/></td>
    <td><img src="./res/016.png" width="200"/></td>
  </tr>
  <tr>
    <td><img src="./res/017.png" width="200"/></td>
    <td><img src="./res/018.png" width="200"/></td>
    <td><img src="./res/019.png" width="200"/></td>
    <td><img src="./res/020.png" width="200"/></td>
  </tr>
  <tr>
    <td><img src="./res/021.png" width="200"/></td>
    <td><img src="./res/022.png" width="200"/></td>
    <td><img src="./res/023.png" width="200"/></td>
    <td><img src="./res/024.png" width="200"/></td>
  </tr>
</table>

<br/>
<br/>